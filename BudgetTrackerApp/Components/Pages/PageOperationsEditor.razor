@page "/operationseditor"
@using BudgetTrackerApp.Data
@using BudgetTrackerApp.Services
@using Microsoft.EntityFrameworkCore
@using System.Threading.Tasks
@rendermode InteractiveServer
@inject DatabaseSelectorService DbSelector

@inject IDbContextFactory<AppDbContext> DbFactory
@inject CategoryService CategoryService


<h1>Edition d'op√©rations</h1>

<select class="form-select" @bind="SelectedValue" @bind:after="OnOptionChanged">
    <option value="A">Op√©rations avec Type manquant</option>
    <option value="B">Ch√®ques uniquement</option>
    <option value="C">Dernier import</option>
    <option value="D">Erreur categorie</option>
</select>

<button class="btn btn-primary btn-sm" @onclick="() => Refresh()"> Refresh </button>

<p>@TextResult</p>

@if (IsLoading)
{
    <div class="alert alert-info">Chargement des op√©rations...</div>
}
else
{
    <table class="table table-striped">
        <thead>
            <tr>
                <th>Date</th>
                <th>Description</th>
                <th class="text-end">Montant</th>
                <th>Type</th>
                <th></th>
                <th>Commentaire</th>
                <th>Banque</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var op in resultatOperations)
            {
                <tr>
                    <td>@op.Date</td>
                    <td>@op.Description</td>
                    <td class="text-end @(op.Montant < 0 ? "text-danger" : "text-success")">
                        @op.Montant.ToString("N2")
                    </td>
                    <td>
                        <select value="@op.Categorie" @onchange="(e) => OnTypeChanged(e, op)" class="form-select">
                            <option value=""></option>
                            @foreach (var cat in categories)
                            {
                                <option value="@cat.Name">@cat.Name</option>
                            }
                        </select>
                    </td>
                    <td>
                        @if (op.IsModified)
                        {
                            <button class="btn btn-primary btn-sm" @onclick="() => SaveType(op)">
                                Enregistrer
                            </button>
                        }
                    </td>
                    <td>
                        <input class="form-control" value="@op.Commentaire" @onchange="(e) => SaveComment(e, op)" />
                    </td>
                    <td>@op.Banque</td>
                </tr>
            }
        </tbody>
    </table>
}



@code {

    private string SelectedValue { get; set; } = "";

    // Indicate to UI that operations are loading
    private bool IsLoading { get; set; } = false;

    private List<Category> categories = new();


    private Dictionary<string, Func<Task>> actions = new();
    private string TextResult = "";

    public List<OperationCC> resultatOperations { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        actions = new Dictionary<string, Func<Task>>
            {
                { "A", FiltrerTypeManquant },
                { "B", FiltrerCheques },
                { "C", FiltrerDernierImport },
                { "D", FiltrerErreurCat }
            };

        categories = await CategoryService.GetAllCategoriesAsync();

        SelectedValue = "C";
        await FiltrerDernierImport();

        // üî• On s‚Äôabonne pour √™tre notifi√© du changement
        DbSelector.OnChange += RefreshOnChange;
    }

    private void OnOptionChanged()
    {
        Console.WriteLine($"SelectedValue (apr√®s bind) = {SelectedValue}");

        if (actions.TryGetValue(SelectedValue, out var action))
        {
            action.Invoke();
        }
    }

    private async Task FiltrerTypeManquant()
    {
        IsLoading = true;
        resultatOperations = new List<OperationCC>();
        StateHasChanged(); // rafra√Æchi l‚ÄôUI imm√©diatement

        await Task.Run(() =>
        {

            using var db = DbFactory.CreateDbContext();

            var operations = db.Operations
    .Where(op => string.IsNullOrEmpty(op.Categorie))
    @* .Select(op => new
            {
                Date = DateTime.Parse(op.Date),
                Banque = op.Banque
            }) *@
    .ToList();

            resultatOperations = operations.Select(TraiterOperation).ToList();
        });

        TextResult = $"{resultatOperations.Count} op√©rations sans Type trouv√©es dans la BDD {DbSelector.CurrentDatabase}";
        IsLoading = false;
        await InvokeAsync(StateHasChanged);
    }

    private string GetAutoCategory(OperationCC op)
    {
        using var db = DbFactory.CreateDbContext();

        Console.WriteLine($"DB: {db.Database.GetDbConnection().DataSource}");

        var rules = db.AutoCategoryRules.ToList();

        Console.WriteLine($"---> op.Decription = {op.Description} <---");
        
        foreach (var r in rules)
        {
            Console.WriteLine($"-----\nId de la r√®gle = {r.Id}");
            if (string.IsNullOrEmpty(r.Category))
                continue; // If no category set, ignore this rule

            // Check if Description is matching pattern
            if (!string.IsNullOrEmpty(r.Pattern) && !string.IsNullOrEmpty(op.Description) && !op.Description.Contains(r.Pattern, StringComparison.OrdinalIgnoreCase))
                continue;

            // Check if amount is below minimum
            if (r.MinAmount.HasValue)
                Console.WriteLine($"{op.Description} {op.Montant} < {r.MinAmount.Value} : {op.Montant < r.MinAmount.Value}");
            else
                Console.WriteLine($"r.MinAmount.HasValue = {r.MinAmount.HasValue}");

            if (r.MinAmount.HasValue && op.Montant < r.MinAmount.Value)
                continue;

            // Check if amount is above maximum
            if (r.MaxAmount.HasValue)
                Console.WriteLine($"{op.Description} {op.Montant} > {r.MaxAmount.Value} : {op.Montant > r.MaxAmount.Value}");
            else
                Console.WriteLine($"r.MaxAmount.HasValue = {r.MaxAmount.HasValue}");

            if (r.MaxAmount.HasValue && op.Montant > r.MaxAmount.Value)
                continue;

            // Check if date is before minimum
            if (r.MinDate.HasValue)
                Console.WriteLine($"{op.Description} {op.Date} > {r.MinDate.Value} : {DateTime.Parse(op.Date) >= r.MinDate.Value}");
            else
                Console.WriteLine($"r.MinDate.HasValue = {r.MinDate.HasValue}");

            if (r.MinDate.HasValue && DateTime.Parse(op.Date) < r.MinDate.Value)
                continue;

            // Check if date is after maximum
            if (r.MaxDate.HasValue)
                Console.WriteLine($"{op.Description} {op.Date} > {r.MaxDate.Value} : {DateTime.Parse(op.Date) >= r.MaxDate.Value}");
            else
                Console.WriteLine($"r.MaxDate.HasValue = {r.MaxDate.HasValue}");

            if (r.MaxDate.HasValue && DateTime.Parse(op.Date) > r.MaxDate.Value)
                continue;

            // Every thing is matching
            Console.WriteLine($"Find a match with \"{r.Category}\" (ID #{r.Id})");

            return r.Category;
        }

        Console.WriteLine($"No auto category found");

        return "";
    }

    private void OnTypeChanged(ChangeEventArgs e, OperationCC op)
    {
        Console.WriteLine($"Changement Type");
        op.Categorie = e.Value?.ToString();
        op.IsModified = true;
    }


    private async Task FiltrerCheques()
    {
        IsLoading = true;
        resultatOperations = new List<OperationCC>();
        StateHasChanged(); // rafra√Æchi l‚ÄôUI imm√©diatement

        await Task.Run(() =>
        {
            using var db = DbFactory.CreateDbContext();

            var operations = db.Operations
    .Where(op =>
    op.Description != null &&
    (op.Description.ToUpper().Contains("CHEQUE EMIS") || op.Description.ToUpper().Contains("CHQ ")) &&
    string.IsNullOrEmpty(op.Categorie))
    .ToList();

            resultatOperations = operations.Select(TraiterOperation).ToList();
        });

        TextResult = $"{resultatOperations.Count} Cheques sans Type trouv√©s dans la BDD {DbSelector.CurrentDatabase}";
        IsLoading = false;
        await InvokeAsync(StateHasChanged);
    }

    private async Task FiltrerDernierImport()
    {
        IsLoading = true;
        resultatOperations = new List<OperationCC>();
        StateHasChanged(); // rafra√Æchi l‚ÄôUI imm√©diatement

        string lastDateImport = "";

        await Task.Run(() =>
        {
            using var db = DbFactory.CreateDbContext();

            // Get the latest import date
            var lastDateImport = db.Operations.Max(op => op.DateImport);

            var operations = db.Operations
    .Where(op =>
    op.DateImport == lastDateImport)
    .ToList();

            resultatOperations = operations.Select(TraiterOperation).ToList();
        });

        TextResult = $"{resultatOperations.Count} op√©rations dans l'import le plus r√©cent du {lastDateImport} dans la BDD {DbSelector.CurrentDatabase}";
        IsLoading = false;
        await InvokeAsync(StateHasChanged);

    }


    private async Task FiltrerErreurCat()
    {
        IsLoading = true;
        resultatOperations = new List<OperationCC>();
        StateHasChanged(); // rafra√Æchi l‚ÄôUI imm√©diatement


        await Task.Run(() =>
        {
            using var db = DbFactory.CreateDbContext();

            var validCategories = db.Categories.Select(c => c.Name).ToHashSet();

            Console.WriteLine($"validCategories.length = {validCategories.Count}");
            
            foreach(var cat in validCategories)
            {
                Console.WriteLine($"validCategories = {cat}");
            }

            var operations = db.Operations
                .Where(o => !string.IsNullOrEmpty(o.Categorie) && !validCategories.Contains(o.Categorie))
                .ToList();

            Console.WriteLine($"operations.length = {operations.Count}");
            resultatOperations = operations.ToList();
        });

        TextResult = $"{resultatOperations.Count} op√©ration(s) avec une cat√©gorie incoh√©rente dans la BDD {DbSelector.CurrentDatabase}";
        IsLoading = false;
        await InvokeAsync(StateHasChanged);

    }

    private OperationCC TraiterOperation(OperationCC op)
    {
        if (string.IsNullOrEmpty(op.Categorie))
        {
            op.Categorie = GetAutoCategory(op);

            if (!string.IsNullOrEmpty(op.Categorie))
            {
                op.IsModified = true;
            }
        }

        return op;
    }

    private void Refresh()
    {
        if (actions.TryGetValue(SelectedValue, out var action))
        {
            action.Invoke();
        }
    }

    private async Task SaveType(OperationCC op)
    {
        using var db = DbFactory.CreateDbContext();

        var entity = await db.Operations.FirstAsync(x => x.Id == op.Id);

        entity.Categorie = op.Categorie;

        await db.SaveChangesAsync();

        // En UI : plus consid√©r√© comme modifi√©
        op.IsModified = false;
    }

    private async Task SaveComment(ChangeEventArgs e, OperationCC op)
    {
        Console.WriteLine($"Changement Commentaire");
        op.Commentaire = e.Value?.ToString();

        using var db = DbFactory.CreateDbContext();

        var entity = await db.Operations.FirstAsync(x => x.Id == op.Id);

        entity.Commentaire = op.Commentaire;

        await db.SaveChangesAsync();

    }

    private async Task RefreshOnChange()
    {
        if (actions.TryGetValue(SelectedValue, out var action))
        {
            await action.Invoke();
        }

        // üî• Important : on repasse sur le thread UI
        await InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        // üî• Toujours se d√©sabonner pour √©viter les fuites m√©moire
        DbSelector.OnChange -= RefreshOnChange;
    }
}