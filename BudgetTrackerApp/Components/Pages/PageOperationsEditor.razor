@page "/operationseditor"
@using BudgetTrackerApp.Data
@using BudgetTrackerApp.Models
@using BudgetTrackerApp.Services
@using Microsoft.EntityFrameworkCore
@using System.Threading.Tasks
@rendermode InteractiveServer
@inject DatabaseSelectorService DbSelector
@inject IDbContextFactory<AppDbContext> DbFactory
@inject CategoryService CategoryService


<MudText Typo="Typo.h4" Class="my-8">√âdition d'op√©rations</MudText>

<MudSelect T="string" Label="Filtre" @bind-Value="SelectedValue" @bind-Value:after="OnOptionChanged" Dense="true"
    Class="mb-3" Style="width:300px">

    <MudSelectItem T="string" Value="@("AllOps")">Toutes les op√©rations</MudSelectItem>
    <MudSelectItem T="string" Value="@("A")">Op√©rations avec Type manquant</MudSelectItem>
    <MudSelectItem T="string" Value="@("B")">Ch√®ques uniquement</MudSelectItem>
    <MudSelectItem T="string" Value="@("C")">Dernier import</MudSelectItem>
    <MudSelectItem T="string" Value="@("D")">Erreur cat√©gorie</MudSelectItem>

</MudSelect>

<MudButton Variant="Variant.Filled" Color="Color.Primary" Size="Size.Small" OnClick="Refresh" Class="ms-2">
    Refresh
</MudButton>

@if (IsLoading)
{
    <MudProgressCircular Color="Color.Primary" Indeterminate="true"/>
    <MudAlert Severity="Severity.Info">Chargement des op√©rations...</MudAlert>
}
else
{
    <MudTable Items="@resultatOperations" Dense="true" Hover="true" Bordered="false" Striped="true" Filter="new Func<OperationCC,bool>(FilterFunc1)" >
        <ToolBarContent>
            <MudText Typo="Typo.h6">@TextResult</MudText>
            <MudSpacer />
            <MudTextField @bind-Value="searchString1" Placeholder="Recherche" Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Medium" Class="mt-0"></MudTextField>
        </ToolBarContent>
        <HeaderContent>
            <MudTh><MudTableSortLabel SortBy="new Func<OperationCC, object>(x=>x.Date)">Date</MudTableSortLabel></MudTh>
            <MudTh>Description</MudTh>
            <MudTh Class="text-end"><MudTableSortLabel SortBy="new Func<OperationCC, object>(x=>x.Montant)">Montant</MudTableSortLabel></MudTh>
            <MudTh>Cat√©gorie</MudTh>
            <MudTh></MudTh>
            <MudTh>Commentaire</MudTh>
            <MudTh>Banque</MudTh>
        </HeaderContent>
        <RowTemplate>
            <MudTd DataLabel="Date">@context.Date</MudTd>
            <MudTd DataLabel="Description">@context.Description</MudTd>

            <MudTd DataLabel="Montant" Class="@(context.Montant < 0 ? "text-danger text-end" : "text-success text-end")">
                <div class="d-flex align-center justify-end" style="height:100%">@context.Montant.ToString("N2")</div>
            </MudTd>

            <MudTd DataLabel="Cat√©gorie">
                    <MudSelect T="string" Value="@context.Categorie"
                        Variant="Variant.Outlined"
                        ValueChanged="(value) => OnCategoryChanged(value, context)" Margin="Margin.Dense"
                        Class="@(context.IsModified ? "mud-select-warning" : "")">
                        <MudSelectItem Value='""'></MudSelectItem>
                        @foreach (var cat in categories)
                        {
                            <MudSelectItem Value="@cat.Name">@cat.Name</MudSelectItem>
                        }
                    </MudSelect>
            </MudTd>

            <MudTd DataLabel="Action">
                    @if (context.IsModified)
                    {
                        <MudButton OnClick="() => SaveCategory(context)" Variant="Variant.Filled" Color="Color.Primary"
                            Size="Size.Small">
                            <MudIcon Icon="@Icons.Material.Filled.Save" />
                        </MudButton>
                    }
            </MudTd>

            <MudTd DataLabel="Commentaire">
                <MudTextField @bind-Value="@context.Commentaire" Margin="Margin.Dense" Variant="Variant.Outlined"
                    OnBlur="() => SaveComment(context)" />
            </MudTd>

            <MudTd DataLabel="Banque">@context.Banque</MudTd>
        </RowTemplate>
        <PagerContent>
            <MudTablePager PageSizeOptions="new int[] { 10, 25, 50, 100, int.MaxValue }"
                           RowsPerPageString="Nb d'√©l√©ments par page"
                           InfoFormat="{first_item}-{last_item} of {all_items}"
                           AllItemsText="Tout"
                           />
        </PagerContent>
    </MudTable>
}



@code {

    private string SelectedValue { get; set; } = "";

    // Indicate to UI that operations are loading
    private bool IsLoading { get; set; } = false;

    private string searchString1 = "";

    private List<Category> categories = new();


    private Dictionary<string, Func<Task>> actions = new();
    private string TextResult = "";

    public List<OperationCC> resultatOperations { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        actions = new Dictionary<string, Func<Task>>
{
{ "A", FiltrerTypeManquant },
{ "B", FiltrerCheques },
{ "C", FiltrerDernierImport },
{ "D", FiltrerErreurCat },
{ "AllOps", ToutesOperations }
};

        categories = await CategoryService.GetAllCategoriesAsync();

        SelectedValue = "C";
        await FiltrerDernierImport();

        // üî• On s‚Äôabonne pour √™tre notifi√© du changement
        DbSelector.OnChange += RefreshOnChange;
    }

    private void OnOptionChanged()
    {
        Console.WriteLine($"SelectedValue (apr√®s bind) = {SelectedValue}");

        if (actions.TryGetValue(SelectedValue, out var action))
        {
            action.Invoke();
        }
    }

    private async Task FiltrerTypeManquant()
    {
        IsLoading = true;
        resultatOperations = new List<OperationCC>();
        StateHasChanged(); // rafra√Æchi l‚ÄôUI imm√©diatement

        await Task.Run(() =>
        {

            using var db = DbFactory.CreateDbContext();

            var operations = db.Operations
    .Where(op => string.IsNullOrEmpty(op.Categorie))
    @* .Select(op => new
            {
                Date = DateTime.Parse(op.Date),
                Banque = op.Banque
            }) *@
    .ToList();

            resultatOperations = operations.Select(TraiterOperation).ToList();
        });

        TextResult = $"{resultatOperations.Count} op√©rations correspondantes";
        IsLoading = false;
        await InvokeAsync(StateHasChanged);
    }

    private string GetAutoCategory(OperationCC op)
    {
        using var db = DbFactory.CreateDbContext();

        var rules = db.CategoryRules.ToList();

        foreach (var r in rules)
        {
            if (!r.IsUsed)
                continue;
            
            if (string.IsNullOrEmpty(r.Category))
                continue; // If no category set, ignore this rule

            // Check if Description is matching pattern
            if (!string.IsNullOrEmpty(r.Pattern) && !string.IsNullOrEmpty(op.Description) && !op.Description.Contains(r.Pattern,
            StringComparison.OrdinalIgnoreCase))
                continue;

            // Check if amount is below minimum
            if (r.MinAmount.HasValue && op.Montant < r.MinAmount.Value)
                continue;

            // Check if amount is above maximum
            if (r.MaxAmount.HasValue && op.Montant > r.MaxAmount.Value)
                continue;

            // Check if date is before minimum
            if (r.MinDate.HasValue && DateTime.Parse(op.Date) < r.MinDate.Value)
                continue;

            // Check if date is after maximum
            if (r.MaxDate.HasValue && DateTime.Parse(op.Date) > r.MaxDate.Value)
                continue;

            // Everything is matching
            return r.Category;
        }

        return "";
    }

    private async void OnCategoryChanged(string newCategory, OperationCC op)
    {
        Console.WriteLine($"Changement Type");
        op.Categorie = newCategory;

        await SaveCategory(op);
    }


    private async Task FiltrerCheques()
    {
        IsLoading = true;
        resultatOperations = new List<OperationCC>();
        StateHasChanged(); // rafra√Æchi l‚ÄôUI imm√©diatement

        await Task.Run(() =>
        {
            using var db = DbFactory.CreateDbContext();

            var operations = db.Operations
    .Where(op =>
    op.Description != null &&
    (op.Description.ToUpper().Contains("CHEQUE EMIS") || op.Description.ToUpper().Contains("CHQ ")) &&
    string.IsNullOrEmpty(op.Categorie))
    .ToList();

            resultatOperations = operations.Select(TraiterOperation).ToList();
        });

        TextResult = $"{resultatOperations.Count} op√©rations correspondantes";
        IsLoading = false;
        await InvokeAsync(StateHasChanged);
    }

    private async Task FiltrerDernierImport()
    {
        IsLoading = true;
        resultatOperations = new List<OperationCC>();
        StateHasChanged(); // rafra√Æchi l‚ÄôUI imm√©diatement

        string? lastDateImport = "";

        await Task.Run(() =>
        {
            using var db = DbFactory.CreateDbContext();

            // Get the latest import date
            lastDateImport = db.Operations.Max(op => op.DateImport);

            var operations = db.Operations
    .Where(op =>
    op.DateImport == lastDateImport)
    .ToList();

            resultatOperations = operations.Select(TraiterOperation).ToList();
        });

        TextResult = $"{resultatOperations.Count} op√©rations correspondantes (import du {lastDateImport})";
        IsLoading = false;
        await InvokeAsync(StateHasChanged);

    }

    private async Task ToutesOperations()
    {
        IsLoading = true;
        resultatOperations = new List<OperationCC>();
        StateHasChanged(); // rafra√Æchi l‚ÄôUI imm√©diatement


        await Task.Run(() =>
        {
            using var db = DbFactory.CreateDbContext();

            var validCategories = db.Categories.Select(c => c.Name).ToHashSet();

            var operations = db.Operations.ToList();

            resultatOperations = operations.ToList();
        });

        TextResult = $"{resultatOperations.Count} op√©rations correspondantes";
        IsLoading = false;
        await InvokeAsync(StateHasChanged);
    }


    private async Task FiltrerErreurCat()
    {
        IsLoading = true;
        resultatOperations = new List<OperationCC>();
        StateHasChanged(); // rafra√Æchi l‚ÄôUI imm√©diatement


        await Task.Run(() =>
        {
            using var db = DbFactory.CreateDbContext();

            var validCategories = db.Categories.Select(c => c.Name).ToHashSet();

            Console.WriteLine($"validCategories.length = {validCategories.Count}");

            foreach (var cat in validCategories)
            {
                Console.WriteLine($"validCategories = {cat}");
            }

            var operations = db.Operations
    .Where(o => !string.IsNullOrEmpty(o.Categorie) && !validCategories.Contains(o.Categorie))
    .ToList();

            Console.WriteLine($"operations.length = {operations.Count}");
            resultatOperations = operations.ToList();
        });

        TextResult = $"{resultatOperations.Count} op√©rations correspondantes";
        IsLoading = false;
        await InvokeAsync(StateHasChanged);

    }

    private OperationCC TraiterOperation(OperationCC op)
    {
        if (string.IsNullOrEmpty(op.Categorie))
        {
            op.Categorie = GetAutoCategory(op);

            if (!string.IsNullOrEmpty(op.Categorie))
            {
                op.IsModified = true;
            }
        }

        return op;
    }

    private bool FilterFunc1(OperationCC listOperations) => FilterFunc(listOperations, searchString1);

    private bool FilterFunc(OperationCC listOperations, string searchString)
    {
        if (string.IsNullOrEmpty(listOperations.Description))
            return false;
        if (string.IsNullOrWhiteSpace(searchString))
            return true;
        if (listOperations.Description.Contains(searchString, StringComparison.OrdinalIgnoreCase))
            return true;
        return false;
    }

    private void Refresh()
    {
        if (actions.TryGetValue(SelectedValue, out var action))
        {
            action.Invoke();
        }
    }

    private async Task SaveCategory(OperationCC op)
    {
        using var db = DbFactory.CreateDbContext();

        var entity = await db.Operations.FirstAsync(x => x.Id == op.Id);

        entity.Categorie = op.Categorie;

        await db.SaveChangesAsync();

        // En UI : plus consid√©r√© comme modifi√©
        op.IsModified = false;
    }

    private async Task SaveComment(OperationCC op)
    {
        Console.WriteLine($"Changement Commentaire");

        using var db = DbFactory.CreateDbContext();

        var entity = await db.Operations.FirstAsync(x => x.Id == op.Id);

        entity.Commentaire = op.Commentaire;

        await db.SaveChangesAsync();

    }

    private async Task RefreshOnChange()
    {
        if (actions.TryGetValue(SelectedValue, out var action))
        {
            await action.Invoke();
        }

        // üî• Important : on repasse sur le thread UI
        await InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        // üî• Toujours se d√©sabonner pour √©viter les fuites m√©moire
        DbSelector.OnChange -= RefreshOnChange;
    }
}